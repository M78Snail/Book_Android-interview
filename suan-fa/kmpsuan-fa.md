## KMP算法 {#toc_5}

KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。

给定两个字符串T和W，长度分别为m和n，判断W是否在T中出现，如果出现则返回出现的位置。常规方法是遍历T的每一个位置，然后从该位置开始和W进行匹配，但是这种方法的复杂度是O\(mn\)。kmp算法通过一个O\(n\)的预处理，使匹配的复杂度降为O\(m+n\)。

> 我们要在 字符串**Ｔ＝“ＡＢＣＤＡＢＣＤＡＢＤＥ”中查找 字符串Ｗ＝＂ＡＢＣＤＡＢＤ＂**出现的位置。

| ![](/assets/import6.17.1.png) |
| :---: |


很明显可以看出前６位都是匹配的，然而第７位不匹配，一般的做法就是从Ｔ\[i\]（i从1到9）开始和W开始循环比较。直到i=4，也就是图2，比较成功返回下标4。

| ![](/assets/import6.17.2.png) |
| :---: |


这样比较无异效率很低，然而我们发现在字符串"ABCDAB"之中有两个"AB"，第一次比较失败之后，又循环比较了四次，把W字符串从第一个"AB"的位置移动到了第二个"AB"处（显然这四次比较毫无意义）。于是Knuth、Morris、Pratt这三个人就想了个办法去掉了这些无意义的比较。

然而是怎么实现的呢？就要从Ｗ字符串的部分匹配值（相等的前缀和后缀）说起。

**部分匹配值**

```java
"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；
"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。
```

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以Ｗ字符串"ABCDABD"为例：

> "A"的前缀和后缀都为空集，共有元素的长度为0；

"AB"的前缀为\[A\]，后缀为\[B\]，共有元素的长度为0；

> "ABC"的前缀为\[A, AB\]，后缀为\[BC, C\]，共有元素的长度0；

"ABCD"的前缀为\[A, AB, ABC\]，后缀为\[BCD, CD, D\]，共有元素的长度为0；

> "ABCDA"的前缀为\[A, AB, ABC, ABCD\]，后缀为\[BCDA, CDA, DA, A\]，共有元素为"A"，长度为1；

"ABCDAB"的前缀为\[A, AB, ABC, ABCD, ABCDA\]，后缀为\[BCDAB, CDAB, DAB, AB, B\]，共有元素为"AB"，长度为2；

> "ABCDABD"的前缀为\[A, AB, ABC, ABCD, ABCDA, ABCDAB\]，后缀为\[BCDABD, CDABD, DABD, ABD, BD, D\]，共有元素的长度为0。

从上面我们就得出了字符串Ｗ的部分匹配表：

| ![](/assets/import6.17.3.png) |
| :---: |


我们把部分匹配表存放在一个next\[\]数组中，那部分匹配值究竟怎么用呢？ 我们可以根据部分匹配值计算出向后移动的位数，避免了一位位的比较：

> 移动位数 = 已匹配的字符数 - 对应的部分匹配值

以图１中为例：

前６位已经匹配**（已匹配的字符数 ＝６）**； 　next\[5\] = 2 \(对应的部分匹配值 = 2\); 　 我们可以得出移动位数为 6-2=4位。

> 可以看出next数组的作用，就是在我们匹配失败的时候，确定我们子串需要往后移动的距离，而避免我们的主串指针进行回退。这样可以保证主串在只遍历一遍的情况下找到子串。因此KMP算法的重点就是如何快速的求出这个next数组。  
> **2 求next数组**

next数组是只与子串有关与主串无关的，它记录的是子串到每个字符处那个公共前缀（或后缀）的最大长度。

| ![](/assets/import6.17.4.png) |
| :---: |


